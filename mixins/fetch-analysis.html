<script>
(()=> {
  'use strict';

  if (!window.Zecat) window.Zecat = {};

  /**
   *
   *
   * @polymer
   * @mixinFunction
   */
  Zecat.FetchAnalysis = superClass => class extends superClass {

    /**
    * @event analysis-error Fired when the analysis file could no be parse or
    *                       fetch.
    */

    static get properties() {
      return {
        fetchingAnalysis: {
          type: Boolean,
          value: false,
          readOnly: true,
          notify: true
        }
      };
    }

    static get observers() {
      return [
        '_disableSpyWhileAutoScrolling(autoScrolling)'
      ];
    }

    constructor() {
      super();
      this.analysisErrors = {
        0: 'No element specified to retrieve analysis',
        1: 'Can not fetch analysis file for a non element node',
        2: 'analysis.json could not be found',
        3: 'Analysis fetched a wrong status code',
        4: 'No elements array find in analysis file',
        5: 'No analysis configuration for the given tag name'
      };
    }

    notifyAnalysisError(code) {
      this.dispatchEvent(
          new CustomEvent(
            'analysis-error',
            {
              detail: {
                code,
                description: this.analysisErrors[code]
              },
              bubbles: true,
              composed: true
            }));
    }

    async fetchAnalysisForElement(el, analysisPath) {
      if (!el) {
        this.notifyAnalysisError(0);
        return;
      }
      // TODO: The custom element check could be improved following this example:
      // https://developers.google.com/web/fundamentals/architecture/building-components/shadowdom#findall
      if (el.nodeType != Node.ELEMENT_NODE) {
        this.notifyAnalysisError(1);
        return;
      }

      if (!analysisPath) {
        // wait for the element to be defined in order to access its import path
        await customElements.whenDefined(el.localName);
        analysisPath = `${el.importPath}analysis.json`;
      }

      let fetchAnalysis;

      try {
        this._setFetchingAnalysis(true);
        fetchAnalysis = await fetch(analysisPath);
        this._setFetchingAnalysis(false);
      } catch (err) {
        this._setFetchingAnalysis(false);
        this.notifyAnalysisError(2);
        return;
      }

      if (!fetchAnalysis.ok) {
        this.notifyAnalysisError(3);
        return;
      }

      const {elements} = await fetchAnalysis.json();
      if (!elements || !(elements instanceof Array)) {
        this.notifyAnalysisError(4);
        return;
      }

      const tagName = el.nodeName.toLowerCase();
      const configForEl = elements.find(elConfig => elConfig.tagname === tagName);

      if (!configForEl) {
        this.notifyAnalysisError(5);
        return;
      }

      return configForEl;
    }

  };
})();
</script>
