<link rel="import" href="fetch-analysis.html">

<script>

(()=> {
  'use strict';

  if (!window.Zecat) window.Zecat = {};

  /**
   *
   *
   * @polymer
   * @mixinFunction
   */
  Zecat.Sandbox = (superClass) => class extends Zecat.FetchAnalysis(superClass) {
    
    static get properties() {
      return {
        /**
         * @type {HTMLElement}
         */
        analyzedElement: Object,
        elementAnalysis: Object,
        elementEntities: Array
      };
    }

    static get observers() {
      return [
        '__updateElementAttribute(elementAnalysis.properties.*, analyzedElement)',
        '__updateElementEntities(elementAnalysis, analyzedElement)'
      ];
    }

    constructor() {
      super();
      this._attributeChanged_boundListeners = {};
    }

    get _propertyGroupNames() {
      return [
        'boolean',
        'string',
        'number',
        'date',
        'array',
        'object',
        'generic'
      ];
    }

    __updateElementAttribute(cr, element) {
      const nameSubpath = cr.path.indexOf('.value');
      if (nameSubpath >= 0) {
        const itempath = cr.path.substring(0, nameSubpath);
        const item = this.get(itempath);
        element[item.name] = item.value;
      }
    }

    __updateElementEntities(elementAnalysis) {
      if (!elementAnalysis) return;

      let groups = [];
      
      for (let groupName of this._propertyGroupNames) {
        groups.push({
          name: groupName,
          title: `${groupName.charAt(0).toUpperCase()}${groupName.slice(1)} properties`,
          items: []
        });
      }

      // Process properties
      elementAnalysis.properties.forEach((property, analysisPropertyIndex) => {
        // Array and Object types are uppercase, we want lowercase
        let group = property.type.toLowerCase();

        if (!this._propertyGroupNames.includes(group)) {
          // assign it to the generic group
          group = 'generic';
        }
        const groupIndex = this._propertyGroupNames.indexOf(group);
        const propertyGroupItems = groups[groupIndex].items;
        const groupPropertyIndex = propertyGroupItems.length;
        propertyGroupItems.push(property);
        this.__initializeProperty(property, analysisPropertyIndex, groupIndex, groupPropertyIndex);
      });

      groups.push({
        name: 'method',
        title: 'Methods',
        items: elementAnalysis.methods
      },{
        name: 'event',
        title: 'Events',
        items: elementAnalysis.events
      });
      
      this.elementEntities = groups;
    }

     /**
      * @param {Object} property The property to link.
      * @param {number} analysisPropertyIndex The index of the property in the `elementAnalysis` array.
      * @param {number} groupIndex The index of the property group in the `elementEntities` array.
      * @param {number} groupPropertyIndex The index of the property in its group array `elementEntities[groupIndex]`.
      */
    __initializeProperty(property, analysisPropertyIndex, groupIndex, groupPropertyIndex) {
      property.hyphenatedName = property.name.replace( /([A-Z])/g, "-$1" ).toLowerCase();

      this.linkPaths(
        `elementAnalysis.properties.${analysisPropertyIndex}`,
        `elementEntities.${groupIndex}.items.${groupPropertyIndex}`);

      this._setElementAnalysisProperty(analysisPropertyIndex, this.analyzedElement[property.name]);
      
      const polymerMetadata = property.metadata.polymer;
      
      if (!polymerMetadata || !polymerMetadata.notify) return;
      
      const callback = e => {
        this._setElementAnalysisProperty(analysisPropertyIndex, e.detail.value);
      };
      // Keep a reference to the callback for future event listener removal
      this._attributeChanged_boundListeners[name] = callback;
      this.analyzedElement.addEventListener(`${property.hyphenatedName}-changed`, callback);
    }

    _setElementAnalysisProperty(index, value) {
      this.set(`elementAnalysis.properties.${index}.value`, value);
    }
  };
})();

</script>
