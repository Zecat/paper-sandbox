<link rel="import" href="fetch-analysis.html">

<script>

(()=> {
  'use strict';

  if (!window.Zecat) window.Zecat = {};

  /**
   *
   *
   * @polymer
   * @mixinFunction
   */
  Zecat.Sandbox = (superClass) => class extends Zecat.FetchAnalysis(superClass) {
    
    static get properties() {
      return {
        /**
         * @type {HTMLElement}
         */
        analyzedElement: Object,
        elementAnalysis: Object,
        elementEntities: Array
      };
    }

    static get observers() {
      return [
        '__updateElementAttribute(elementAnalysis.properties.*, analyzedElement)',
        '__updateElementEntities(elementAnalysis, analyzedElement)'
      ];
    }

    constructor() {
      super();
      this._attributeChanged_boundListeners = {};
    }

    get _propertyGroupNames() {
      return [
        'boolean',
        'string',
        'number',
        'date',
        'array',
        'object',
        'generic'
      ];
    }

    __updateElementAttribute(cr, element) {
      const nameSubpath = cr.path.indexOf('.value');
      if (nameSubpath >= 0) {
        const itempath = cr.path.substring(0, nameSubpath);
        const item = this.get(itempath);
        element[item.name] = item.value;
      }
    }

    __updateElementEntities(elementAnalysis) {
      if (!elementAnalysis) return;
      this.elementEntities = this.__generateEntitiesForAnalysis(elementAnalysis);
    }

    __generateEntitiesForAnalysis(elementAnalysis) {
      let groups = [];
      
      for (let groupName of this._propertyGroupNames) {
        groups.push({
          name: groupName,
          title: `${groupName.charAt(0).toUpperCase()}${groupName.slice(1)} properties`,
          items: []
        });
      }

      /**
       * @type {Function}
       * @param {Object} property The property to link.
       * @param {number} analysisPropertyIndex The index of the property in the `elementAnalysis` array.
       */
      const initializeProperty = (property, analysisPropertyIndex) => {
        property.hyphenatedName = property.name.replace( /([A-Z])/g, "-$1" ).toLowerCase();
        // Array and Object types are uppercase, we want lowercase
        let group = property.type.toLowerCase();
        if (!this._propertyGroupNames.includes(group)) {
          // assign it to the generic group
          group = 'generic';
        }
        const groupIndex = this._propertyGroupNames.indexOf(group);
        const propertyGroupItems = groups[groupIndex].items;
        const groupPropertyIndex = propertyGroupItems.length;
        propertyGroupItems.push(property);

        this.linkPaths(
          `elementAnalysis.properties.${analysisPropertyIndex}`,
          `elementEntities.${groupIndex}.items.${groupPropertyIndex}`);

        let polymerMetadata = property.metadata.polymer;

        if (!polymerMetadata || !polymerMetadata.notify) return;

        this._setElementAnalysisProperty(analysisPropertyIndex, this.analyzedElement[property.name]);
        
        const callback = e => {
          this._setElementAnalysisProperty(analysisPropertyIndex, e.detail.value);
        };
        // Keep a reference to the callback for future event listener removal
        this._attributeChanged_boundListeners[name] = callback;
        this.analyzedElement.addEventListener(`${property.hyphenatedName}-changed`, callback);
      };
      
      // Initialize properties
      elementAnalysis.properties.forEach(initializeProperty);

      groups.push({
        name: 'method',
        title: 'Methods',
        isDisplayed: true,
        items: elementAnalysis.methods
      },{
        name: 'event',
        title: 'Events',
        isDisplayed: true,
        items: elementAnalysis.events
      });
      
      return groups;
    }

    _setElementAnalysisProperty(index, value) {
      this.set(`elementAnalysis.properties.${index}.value`, value);
    }
  };
})();

</script>
