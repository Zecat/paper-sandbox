<link rel="import" href="fetch-analysis.html">

<script>

(()=> {
  'use strict';

  if (!window.Zecat) window.Zecat = {};

  /**
   *
   *
   * @polymer
   * @mixinFunction
   * @appliesMixin Zecat.FetchAnalysis
   */
  Zecat.Sandbox = (superClass) => class extends Zecat.FetchAnalysis(superClass) {

    static get properties() {
      return {
        /**
         * @type {HTMLElement}
         */
        analyzedElement: Object,
        elementAnalysis: Object,
        elementEntities: Array,
        cssVariables: {
          type: Array,
          value: () => ([])
        }
      };
    }

    static get observers() {
      return [
        '__updateElementAttribute(elementAnalysis.properties.*, analyzedElement)',
        '__updateElementEntities(elementAnalysis, analyzedElement)',
        '__updateCssVariables(cssVariables, elementEntities, analyzedElement, elementAnalysis)',
        '__updateElementStyles(elementAnalysis.cssVariables.*, analyzedElement)'
      ];
    }

    constructor() {
      super();
      this._attributeChanged_boundListeners = {};
    }

    get _propertyGroupNames() {
      return [
        'boolean',
        'string',
        'number',
        'date',
        'array',
        'object',
        'generic'
      ];
    }

    __updateElementStyles(cr, element) {
      if (cr === undefined || element === undefined) return;

      const nameSubpath = cr.path.indexOf('.value');

      if (nameSubpath >= 0) {
        const itempath = cr.path.substring(0, nameSubpath);
        const item = this.get(itempath);
        element.updateStyles({
          [item.name]: item.value
        });
      }
    }

    __updateElementAttribute(cr, element) {
      const nameSubpath = cr.path.indexOf('.value');
      if (nameSubpath >= 0) {
        const itempath = cr.path.substring(0, nameSubpath);
        const item = this.get(itempath);
        element[item.name] = item.value;
      }
    }

    __updateElementEntities(elementAnalysis) {
      if (!elementAnalysis) return;

      let groups = [];

      for (let groupName of this._propertyGroupNames) {
        groups.push({
          name: groupName,
          title: `${groupName.charAt(0).toUpperCase()}${groupName.slice(1)} properties`,
          items: []
        });
      }

      // Process properties
      elementAnalysis.properties.forEach((property, analysisPropertyIndex) => {
        // Array and Object types are uppercase, we want lowercase
        let group = property.type.toLowerCase();

        if (!this._propertyGroupNames.includes(group)) {
          // assign it to the generic group
          group = 'generic';
        }
        const groupIndex = this._propertyGroupNames.indexOf(group);
        const propertyGroupItems = groups[groupIndex].items;
        const groupPropertyIndex = propertyGroupItems.length;
        propertyGroupItems.push(property);
        this.__initializeProperty(property, analysisPropertyIndex, groupIndex, groupPropertyIndex);
      });

      groups.push({
        name: 'method',
        title: 'Methods',
        items: elementAnalysis.methods
      },{
        name: 'event',
        title: 'Events',
        items: elementAnalysis.events
      });

      this.elementEntities = groups;
    }

     /**
      * @param {Object} property The property to link.
      * @param {number} analysisPropertyIndex The index of the property in the `elementAnalysis` array.
      * @param {number} groupIndex The index of the property group in the `elementEntities` array.
      * @param {number} groupPropertyIndex The index of the property in its group array `elementEntities[groupIndex]`.
      */
    __initializeProperty(property, analysisPropertyIndex, groupIndex, groupPropertyIndex) {
      property.hyphenatedName = property.name.replace( /([A-Z])/g, "-$1" ).toLowerCase();

      this.linkPaths(
        `elementAnalysis.properties.${analysisPropertyIndex}`,
        `elementEntities.${groupIndex}.items.${groupPropertyIndex}`);

      this._setElementAnalysisProperty(analysisPropertyIndex, this.analyzedElement[property.name]);

      const polymerMetadata = property.metadata.polymer;

      if (!polymerMetadata || !polymerMetadata.notify) return;

      const callback = e => {
        this._setElementAnalysisProperty(analysisPropertyIndex, e.detail.value);
      };
      // Keep a reference to the callback for future event listener removal
      this._attributeChanged_boundListeners[name] = callback;
      this.analyzedElement.addEventListener(`${property.hyphenatedName}-changed`, callback);
    }

    _setElementAnalysisProperty(index, value) {
      this.set(`elementAnalysis.properties.${index}.value`, value);
    }

    __updateCssVariables(cssVariables, elementEntities, analyzedElement, elementAnalysis) {
      if (elementAnalysis === undefined ||
          !(analyzedElement instanceof HTMLElement) ||
          !(elementEntities instanceof Array) ||
          !(cssVariables instanceof Array) ||
          !cssVariables.length) return;

      // The observer is sometime call twice, this is a hack for not adding css variables a second time
      if (elementEntities.find(group => group.name === 'cssVariable')) return;

      const cssVariableItems = [];

      for (let cssVariable of cssVariables) {
        const cssVariableItem = Object.assign(
          cssVariable,
          {
            value: cssVariable.defaultValue,
            privacy: 'public'
          }
        );

        cssVariableItems.push(cssVariableItem);
      }

      const cssVariableGroup = {
        name: 'cssVariable',
        title: 'CSS variables',
        items: cssVariableItems
      };

      const groupIndex = this.elementEntities.length;

      this.push('elementEntities', cssVariableGroup);

      this.set('elementAnalysis.cssVariables', cssVariableGroup.items);

      this.linkPaths(
        `elementAnalysis.cssVariables`,
        `elementEntities.${groupIndex}.items`);
    }
  };
})();

</script>
