<script>
  
(()=> {
  'use strict';

  if (!window.Zecat) window.Zecat = {};

  /**
   * 
   * 
   * @polymer
   * @mixinFunction
   */
  Zecat.ParseAnalysis = (superClass) => class extends superClass {

    constructor() {
      super();
    }

    connectedCallback() {
      super.connectedCallback();
    }

    disconnectedCallback() {
      super.disconnectedCallback();
    }

    get groups() {
      return [
        'boolean',
        'string',
        'number',
        'array',
        'object',
        'function',
        'date',
        'generic'
      ];
    }

    get emptySandboxDescriptor() {
      let descriptor = {
        properties: {},
        count: {
          nonInheritedMethods: 0
        },
        events: [],
        methods: []
      };

      for (let type of this.groups) {
        descriptor.properties[type] = [];
        descriptor.count[type] = {
          public: 0,
          total: 0
        };
      }
      return descriptor;
    }

    parseAnalysis(analysis) {
      let descriptor = this.emptySandboxDescriptor;

      for (let {type, name, defaultValue, description, privacy, metadata} of analysis.properties) {
        // Array and Object types are uppercase
        let group = type.toLowerCase();
        let propertyDescriptor = {};
        
        // if the property type is not managed
        if (!this.groups.includes(group)) {
          // store the type in the property descriptor
          propertyDescriptor.type = type;
          // assign it to the generic group
          group = 'generic';
        }

        if (privacy === 'public') {
          descriptor.count[group].public++;
        }
        // TODO: get ride of the total count
        descriptor.count[group].total++;

        if (defaultValue !== undefined) {
          try {
            defaultValue = JSON.parse(defaultValue);
          } catch(e) {
            defaultValue = undefined;
          }
        }

        propertyDescriptor = Object.assign(propertyDescriptor, {
          name,
          description,
          privacy,
          defaultValue,
          value: defaultValue
        });

        if (metadata.polymer && Object.keys(metadata.polymer).length) {
          // assign any polymer metadata (e.g. notify, readOnly...)
          propertyDescriptor = Object.assign(propertyDescriptor, metadata.polymer);
        }
        descriptor.properties[group].push(propertyDescriptor);
      }
      

      for (let {name, description, params, privacy, inheritedFrom} of analysis.methods) {
        if (inheritedFrom === undefined) {
          descriptor.count.nonInheritedMethods++;
        }

        descriptor.methods.push({
          name,
          description,
          params: params.map(p => Object.assign(p, {value: undefined})),
          privacy,
          inheritedFrom
        });
      }
      for (let {name, description} of analysis.events) {
        descriptor.events.push({name, description});
      }
      Object.assign(descriptor, {styling: analysis.styling, slots: analysis.slots, tagname: analysis.tagname});
      
      return descriptor;
    }

  };
})();

</script>
