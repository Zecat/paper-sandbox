<script>

(()=> {
  'use strict';

  if (!window.Zecat) window.Zecat = {};

  /**
   *
   *
   * @polymer
   * @mixinFunction
   */
  Zecat.ParseAnalysis = (superClass) => class extends superClass {

    constructor() {
      super();
    }

    connectedCallback() {
      super.connectedCallback();
    }

    disconnectedCallback() {
      super.disconnectedCallback();
    }

    get groups() {
      return [
        'boolean',
        'string',
        'number',
        'array',
        'object',
        'function',
        'date',
        'generic'
      ];
    }

    get emptySandboxDescriptor() {
      let descriptor = {
        properties: {},
        count: {
          nonInheritedMethods: 0
        },
        events: [],
        methods: []
      };

      for (let type of this.groups) {
        descriptor.properties[type] = [];
        descriptor.count[type] = {
          public: 0,
          total: 0,
          notInherited: 0,
          publicNotInherited: 0,
          publicInherited: 0
        };
      }
      return descriptor;
    }

    parseAnalysis(analysis) {
      let descriptor = this.emptySandboxDescriptor;

      this._updateDescriptorProperties(descriptor, analysis.properties);
      this._updateDescriptorMethods(descriptor, analysis.methods);
      this._updateDescriptorEvents(descriptor, analysis.events);

      Object.assign(descriptor, {styling: analysis.styling, slots: analysis.slots, tagname: analysis.tagname});

      return descriptor;
    }

    _updateDescriptorProperties(descriptor, analysisProperties) {
      for (let property of analysisProperties) {
        let {
          type,
          name,
          defaultValue,
          description,
          privacy,
          metadata,
          inheritedFrom
        } = property;
        // Array and Object types are uppercase, we want lowercase
        let group = type.toLowerCase();
        let propertyDescriptor = {};

        // if the property type is not managed
        if (!this.groups.includes(group)) {
          // store the type in the property descriptor
          propertyDescriptor.type = type;
          // assign it to the generic group
          group = 'generic';
        }

        let count = descriptor.count[group];

        count.total++;

        const isPublic = privacy === 'public';
        const isNotInherited = inheritedFrom === undefined;

        if (isNotInherited) {
          count.notInherited++;
          if (isPublic) {
            count.publicNotInherited++;
          }
        } else if (isPublic) {
          count.publicInherited++;
        }

        if (defaultValue !== undefined) {
          try {
            defaultValue = JSON.parse(defaultValue);
          } catch(e) {
            defaultValue = undefined;
          }
        }

        propertyDescriptor = Object.assign(propertyDescriptor, {
          name,
          description,
          privacy,
          inheritedFrom,
          defaultValue,
          value: defaultValue
        });

        if (metadata.polymer && Object.keys(metadata.polymer).length) {
          // assign any polymer metadata (e.g. notify, readOnly...)
          propertyDescriptor = Object.assign(propertyDescriptor, metadata.polymer);
        }
        descriptor.properties[group].push(propertyDescriptor);
      }
    }

    _updateDescriptorMethods(descriptor, analysisMethods) {
      for (let method of analysisMethods) {
        let {
          name,
          description,
          params,
          privacy,
          inheritedFrom
        } = method;

        if (inheritedFrom === undefined) {
          descriptor.count.nonInheritedMethods++;
        }

        descriptor.methods.push({
          name,
          description,
          params: params.map(p => Object.assign(p, {value: undefined})),
          privacy,
          inheritedFrom
        });
      }
    }

    _updateDescriptorEvents(descriptor, analysisEvent) {
      for (let {name, description} of analysisEvent) {
        descriptor.events.push({name, description});
      }
    }
  };
})();

</script>
