<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../shadycss/apply-shim.html">
<link rel="import" href="../polymer/lib/utils/templatize.html">
<link rel="import" href="paper-sandbox-configuration.html">
<link rel="import" href="sandbox-descriptor-mixin.html">

<dom-module id="paper-sandbox">
  <template>
    <style>
      :host {
        display: block;
        @apply --layout-vertical;
      }
      #demoContainer {
        @apply --paper-sandbox-demo-container;
        @apply --layout-center;
        max-width: 300px;
        margin: 42px auto;
      }
      paper-sandbox-configuration {
        position: fixed;
        top: 0;
        left: 0;
        overflow: auto;
        height: 100vh;
      }
    </style>

    <slot id="slot" on-slotchange="_slotChangeHandler"></slot>

    <div id="demoContainer"></div>

    <paper-sandbox-configuration
        configuration="{{descriptor}}"
        element="[[analyzedElement]]">
    </paper-sandbox-configuration>

  </template>


  <script>
    /**
     * Missing Description
     * 
     * @customElement
     * @polymer
     * @appliesMixin Zecat.SandboxDescriptorMixin 
     * @demo demo/index.html
     */
    class PaperSandbox extends Zecat.SandboxDescriptorMixin(Polymer.Element) {

      static get is() { return 'paper-sandbox'; }

      static get properties() {
        return {
          /**
           * The tag name of the element you want to produce a sandbox for.
           * @type {String}
           */
          tag: String,
          /**
           * @type {HTMLElement}
           */
          analyzedElement: {
            type: Object,
            notify: true
          },
          fetchingAnalysis: {
            type: Boolean,
            value: false,
            readOnly: true,
            notify: true
          },
        };
      }

      static get observers() {
        return [
          '_analyzedElementChanged(analyzedElement)'
        ]
      }

      constructor() {
        super();
        this.analysisErrors = {
          0: 'No element specified to retrieve analysis',
          1: 'Can not fetch analysis for a non element node',
          2: 'Analysis fetch error',
          3: 'Analysis fetched a wrong status code',
          4: 'No elements array find in analysis file',
          5: 'No analysis configuration for the given tag name'
        };
      }

      connectedCallback() {
        super.connectedCallback();
      }

      disconnectedCallback() {
        super.disconnectedCallback();
      }

      ready() {
        super.ready()
        this._assignedNodesChange(this.$.slot.assignedNodes({flatten: true}));
      }

      twrowAnalysisError(code) {
        throw new Error({code, description: this.analysisErrors[code]});
      }

      async fetchDescriptorForElement(el, analysisPath) {
        if (!el) this.twrowAnalysisError(0);
        // TODO: The custom element check could be improved following this example:
        // https://developers.google.com/web/fundamentals/architecture/building-components/shadowdom#findall
        if (el.nodeType != Node.ELEMENT_NODE) this.twrowAnalysisError(1);
        
        if (!analysisPath) {
          analysisPath = `${el.importPath}analysis.json`;
        }

        let fetchAnalysis;

        try {
          this._setFetchingAnalysis(true);
          fetchAnalysis = await fetch(analysisPath);
          this._setFetchingAnalysis(false);
        } catch (err) {
          this._setFetchingAnalysis(false);
          this.twrowAnalysisError(2);
        }

        if (!fetchAnalysis.ok) this.twrowAnalysisError(3);

        const {elements} = await fetchAnalysis.json();
        if (!elements || !(elements instanceof Array)) this.twrowAnalysisError(4);

        const tagName = el.nodeName.toLowerCase();
        const configForEl = elements.find(elConfig => elConfig.tagname === tagName);

        if (!configForEl) this.twrowAnalysisError(5);

        return configForEl;
      }

      _slotChangeHandler(e) {
        this._assignedNodesChange(e.target.assignedNodes({flatten: true}));
      }

      _assignedNodesChange(assignedNodes) {
        if (!assignedNodes) return;

        // Find the first template 
        const template = assignedNodes.find(n => n.nodeName === 'TEMPLATE');
        if (!template) return;
        
        this.ctr = Polymer.Templatize.templatize(template, this);
        this.stamped = new this.ctr({});

        this.$.demoContainer.appendChild(this.stamped.root);
        
        this.analyzedElement = this.$.demoContainer.querySelector(this.tag);
      }

      async _analyzedElementChanged(analyzedElement) {
        if (!analyzedElement) return;
        
        try {
          this.analysis = await this.fetchDescriptorForElement(this.analyzedElement);
        } 
        catch (err) {
          this.analysisErrorCode = err.code;
          this.dispatchEvent(
            new CustomEvent(
              'analysis-error',
              {
                detail: err,
                bubbles: true,
                composed: true
              }));
        }
      }

    }

    customElements.define(PaperSandbox.is, PaperSandbox);

  </script>
</dom-module>
