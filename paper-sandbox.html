<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../shadycss/apply-shim.html">
<link rel="import" href="../polymer/lib/utils/templatize.html">
<link rel="import" href="sandbox-configuration.html">

<dom-module id="paper-sandbox">
  <template>
    <style>
      :host {
        display: block;
        @apply --layout-vertical;
      }
      #demoContainer {
        @apply --paper-sandbox-demo-container;
        @apply --layout-center;
        max-width: 300px;
        margin: 42px auto;
      }
      sandbox-configuration {
        position: fixed;
        top: 0;
        left: 0;
        overflow: auto;
        height: 100vh;
        /* position: absolute; */
        /* bottom: 0; */
      }
    </style>

    <slot id="slot" on-slotchange="_slotChangeHandler"></slot>

    <div id="demoContainer"></div>

    <sandbox-configuration
        configuration="{{configuration}}"
        element="[[analyzedElement]]"
    ></sandbox-configuration>

  </template>


  <script>
    /**
     * Missing Description
     * 
     * #appliesMixin 
     * @customElement
     * @polymer
     * @demo demo/index.html
     */
    class PaperSandbox extends Polymer.Element {

      static get is() { return 'paper-sandbox'; }

      static get properties() {
        return {
          /**
           * The tag name of the element you want to produce a sandbox for.
           * @type {String}
           */
          tag: String,
          configuration: Object,
          analyzedElement: {
            type: HTMLElement,
            notify: true
          },
          fetchingAnalysis: {
            type: Boolean,
            value: false,
            readOnly: true,
            notify: true
          },
        };
      }

      static get observers() {
        return [
          '_updateElementAttribute(configuration.properties.*, analyzedElement)'
        ];
      }

      constructor() {
        super();
      }

      connectedCallback() {
        super.connectedCallback();
      }

      disconnectedCallback() {
        super.disconnectedCallback();
      }

      ready() {
        super.ready()
        this._assignedNodesChange(this.$.slot.assignedNodes({flatten: true}));
      }

      async fetchDescriptorForElement(el, analysisPath) {
        if (!el) throw new Error('No element specified to retrieve analysis');
        // TODO: The custom element check could be improved following this example:
        // https://developers.google.com/web/fundamentals/architecture/building-components/shadowdom#findall
        if (el.nodeType != Node.ELEMENT_NODE) throw new Error('Can not fetch analysis for a non element node');
        
        if (!analysisPath) {
          analysisPath = `${el.importPath}analysis.json`;
        }

        let fetchAnalysis;

        try {
          this._setFetchingAnalysis(true);
          fetchAnalysis = await fetch(analysisPath);
          this._setFetchingAnalysis(false);
        } catch (err) {
          this._setFetchingAnalysis(false);
          throw new Error('Analysis fetch error');
        }

        if (!fetchAnalysis.ok) throw new Error('Analysis fetched a wrong status code');

        const {elements} = await fetchAnalysis.json();
        if (!elements || !(elements instanceof Array)) throw new Error('No elements array find in analysis file');

        const tagName = el.nodeName.toLowerCase();
        const configForEl = elements.find(elConfig => elConfig.tagname === tagName);

        if (!configForEl) throw new Error('No analysis configuration for the given tag name');

        return configForEl;
      }

      _slotChangeHandler(e) {
        // TODO: test
        const assignedNodes = e.target.assignedNodes({flatten: true});
      }

      async _assignedNodesChange(assignedNodes) {
        if (!assignedNodes) return;

        // Find the first template 
        const template = assignedNodes.find(n => n.nodeName === 'TEMPLATE');
        if (!template) return;
        
        this.ctr = Polymer.Templatize.templatize(template, this);
        this.stamped = new this.ctr({});

        this.$.demoContainer.appendChild(this.stamped.root);
        
        this.analyzedElement = this.$.demoContainer.querySelector(this.tag);
        if (!this.analyzedElement) return;
        
        try {
          this.descriptor = await this.fetchDescriptorForElement(this.analyzedElement);
        } 
        catch (err) {
          // TODO: manage errors
          console.warn(err)
        }
      }

      get emptyConfiguration() {
        return {
          properties: {
            boolean: [],
            string: [],
            number: [],
            object: [],
            function: []
          },
          events: [],
          methods: []
        };
      }

      set descriptor(descriptor) {
        let configuration = this.emptyConfiguration;

        for (let {type, name, description, privacy} of descriptor.properties) {
          if (!configuration.properties[type]) {
            configuration.properties[type] = [];
          } 
          configuration.properties[type].push({
            name,
            description,
            privacy,
            value: undefined
          });
        }
        for (let {name, description, params, privacy} of descriptor.methods) {
          configuration.methods.push({
            name,
            description,
            params: params.map(p => Object.assign(p, {value: undefined})),
            privacy
          });
        }
        for (let {name, description} of descriptor.events) {
          configuration.events.push({name, description});
        }
        Object.assign(configuration, {styling: descriptor.styling, slots: descriptor.slots, tagname: descriptor.tagname});

        this.configuration = configuration;

        descriptor.attributes.forEach(({type, name}, i) => {
          this.analyzedElement.addEventListener(`${name}-changed`, e => {
            this.set(`configuration.attributes.${type}.${i}.value`, e.detail.value);
          });
        })
        
      }

      _updateElementAttribute(cr, element) {
        var nameSubpath = cr.path.indexOf('.value');
        if (nameSubpath >= 0) {
          let type = cr.path.split('.')[2];
          var itempath = cr.path.substring(0, nameSubpath);
          var item = this.get(itempath);
          var index = cr.base[type].indexOf(item);
          element[item.name] = item.value;
        }
      }
    }

    window.customElements.define(PaperSandbox.is, PaperSandbox);

  </script>
</dom-module>
