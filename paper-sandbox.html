<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../paper-input/paper-input.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../paper-checkbox/paper-checkbox.html">
<link rel="import" href="../paper-number-input/paper-number-input.html">
<link rel="import" href="../paper-styles/typography.html">
<link rel="import" href="../paper-styles/shadow.html">
<link rel="import" href="mixins/sandbox.html">
<link rel="import" href="paper-sandbox-icons.html">
<link rel="import" href="paper-sandbox-method.html">
<link rel="import" href="paper-sandbox-object.html">
<link rel="import" href="paper-sandbox-css-variable.html">
<link rel="import" href="paper-sandbox-attachments-button.html">

<dom-module id="paper-sandbox">
  <template strip-whitespace>
    <style>
      :host {
        display: block;
        position: relative;
      }
      .section {
        @apply --layout-vertical;
      }
      .section:last-of-type {
        min-height: 100%;
      }
      .section {
        background: var(--paper-grey-50);
      }
      .group-header {
        @apply --paper-font-subhead;
        position: sticky;
        top: 0;
        background: inherit;
        height: 64px;
        padding: 0 64px 0 38px;
        z-index: 1;
        @apply --shadow-transition;
        @apply --layout-center;
        @apply --layout-justified;
        @apply --layout-horizontal;
      }
      .group-header:before {
        display: block;
        content: '';
        height: 1px;
        position: absolute;
        /* Makes the divider disapear when the toolbar is at the top of the screen */
        top: -1px;
        /* Lets a space for the icon button */
        right: 64px;
        left: 0;
        background: var(--paper-grey-200);
      }
      .group-header.elevated {
        @apply --shadow-elevation-2dp;
      }
      .list paper-sandbox-method {
        margin: 12px;
        min-width: 200px;
        height: 40px;
      }
      .list paper-checkbox {
        padding: 8px 12px;
      }
      .list paper-input,
      .list paper-number-input,
      .list paper-sandbox-css-variable {
        margin: 0 12px;
      }
      .list paper-sandbox-object {
        margin: 16px;
        z-index: 0;
      }
      #moreBtn {
        display: block;
        position: sticky;
        top: 12px;
        margin-left: calc(100% - 50px);
        z-index: 2;
        margin-top: -40px;
      }
      .list {
        padding: 24px 74px 42px 24px;
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(220px, 1fr));
      }
      .array > .list,
      .object > .list,
      .generic > .list,
      .method > .list,
      .cssVariable > .list {
        grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
      }
    </style>

    <paper-icon-button id="moreBtn" icon="more-vert"></paper-icon-button>

    <template is="dom-repeat" id="sectionsDomRepeat"
        items="{{elementEntities}}"
        as="group"
        filter="[[_groupFilter]]">
      <div class$="section [[group.name]]">
        <div class="group-header">
          <span>[[group.title]]</span>
          <template is="dom-if" if="[[_groupHasAttachment(attachments, group.name)]]">
            <paper-sandbox-attachments-button
              attachments="[[_getAttachment(attachments, group.name)]]"
              items="{{group.items}}"
            ></paper-sandbox-attachments-button>
          </template>
        </div>
        <div class="list">
          <dom-repeat class="dom-repeat-items" items="{{group.items}}" filter="[[_itemFilter]]"></dom-repeat>
        </div>
      </div>
    </template>

  </template>

  <script>
    /**
     *
     *
     * @customElement
     * @polymer
     * @appliesMixin Zecat.Sandbox
     */
    class PaperSandbox extends Zecat.Sandbox(Polymer.Element) {

      static get is() { return 'paper-sandbox'; }

      static get properties() {
        return {
          showPrivate: {
            type: Boolean,
            value: false
          },
          attachments: {
            type: Object
          },
          showInherited: {
            type: Boolean,
            value: false
          },
          _itemFilter: {
            type: Function,
            computed: '_compute_itemFilter(filters.*)'
          },
          _groupFilter: {
            type: Function,
            computed: '_compute_groupFilter(_itemFilter)'
          },
          filters: {
            type: Object,
            computed: '_computeFilters(elementEntities, initialDisplayedInheritance)'
          },
          initialDisplayedInheritance: {
            type: Array,
            value: () => [this.notInheritedLabel]
          }
        };
      }

      static get notInheritedLabel() {
        return 'Not Inherited';
      }

      constructor() {
        super();
        this.addEventListener('method-triggered', this._methodTriggeredHandler.bind(this));
        this.groupsTemplate = {
          boolean: `<paper-checkbox checked="{{item.value}}">
                        [[item.hyphenatedName]]
                    </paper-checkbox>`,

          string: `<paper-input label="[[item.hyphenatedName]]"
                      value="{{item.value}}">
                  </paper-input>`,

          number: `<paper-number-input
                      label="[[item.hyphenatedName]]"
                      value="{{item.value}}"
                      step="0.1">
                  </paper-number-input>`,

          date: `<paper-input
                    label="[[item.hyphenatedName]]"
                    value="{{item.value}}">
                </paper-input>`,

          array: `<paper-sandbox-object
                      label="[[item.hyphenatedName]]"
                      default-value="[[item.defaultValue]]"
                      value="{{item.value}}">
                  </paper-sandbox-object>`,

          object: `<paper-sandbox-object
                      label="[[item.hyphenatedName]]"
                      default-value="[[item.defaultValue]]"
                      value="{{item.value}}">
                  </paper-sandbox-object>`,

          generic: `<paper-sandbox-object
                        label="[[item.hyphenatedName]]"
                        default-value="[[item.defaultValue]]"
                        value="{{item.value}}"
                        type="[[item.type]]">
                    </paper-sandbox-object>`,

          method: `<paper-sandbox-method
                      name="[[item.name]]"
                      description="[[item.description]]"
                      params="{{item.params}}">
                  </paper-sandbox-method>`,

          cssVariable: `<paper-sandbox-css-variable item="{{item}}">
                        </paper-sandbox-css-variable>`
        };
      }

      connectedCallback() {
        super.connectedCallback();

        /**
         * @type {Function}
         * @param {Object} mutations The mutations descriptor
         * Handler for node mutations on this element's shadow root.
         */
        const shadowNodeMutationsHandler = mutations => {
          for (let {addedNodes} of mutations) {
            for (let addedNode of addedNodes) {
              if (!addedNode.classList.contains('section')) break;
              // Here, the addedNode is a 'section' that we want to process

              this.__processAddedSection(addedNode);
            }
          }    
        };

        /**
         * @type {MutationObserver}
         * An mutation observer ready to process added sections nodes.
         */
        const observer = new MutationObserver(shadowNodeMutationsHandler);

        /**
         * @type {boolean}
         * Whether or not the shadow dom is native or a polyfill.
         */
        const native = this.shadowRoot.mode != undefined;

        // Activate the observer which processes added sections nodes.
        observer.observe(native ? this.shadowRoot : this, {childList: true});
      }

      /**
       * Processes an added section node in this element shadow dom.
       * 
       * Generates section content and create an intersection observer
       * to display a shadow on the section toolbar when it intersects with
       * its main content.
       *
       * @param {HTMLElement} sectionNode The section node to process.
       */
      __processAddedSection(sectionNode) {
        const model = this.$.sectionsDomRepeat.modelForElement(sectionNode);
        const groupName = model.group.name;
        const groupTemplate = this._getInputTemplate(groupName);
        const domRepeat = sectionNode.querySelector('.dom-repeat-items');

        // Generate content adding the right template to the dom-repeat
        domRepeat.appendChild(groupTemplate);

        /**
         * @type {HTMLElement}
         * The section toolbar.
         */
        const toolbar = sectionNode.querySelector('.group-header');

        /**
         * @type {{root: HTMLElement, rootMargin: String}}
         * The intersection observer options.
         */
        const options = {
            root: sectionNode,
            rootMargin: `-${toolbar.clientHeight+2}px 0px 0px 0px`
        };
        const observer = new IntersectionObserver(this.__sectionToolbarIntersectCallback, options);

        observer.observe(toolbar);
      }

      __sectionToolbarIntersectCallback({[0]: entry}) {
        entry.target.classList.toggle('elevated', entry.isIntersecting);
      }

      _compute_groupFilter(_itemFilter) {
        return group => group.items.find(_itemFilter);
      }

      _getInputTemplate(groupName) {
        const template = document.createElement('template');
        template.innerHTML = this.groupsTemplate[groupName];
        return template;
      }

      _compute_itemFilter() {
        return item => {
          const findFilterForInheritance = inheritedFrom => {
            return this.filters.find(filter => filter.inheritedFrom === inheritedFrom);
          };
          const inheritedFrom = item.inheritedFrom || this.constructor.notInheritedLabel;
          const filter = findFilterForInheritance(inheritedFrom);

          return filter.selected && filter[item.privacy];
        };
      }

      _methodTriggeredHandler(e) {
        const {name, params} = e.detail;
        e.composedPath()[0].lastResponse = this.analyzedElement[name](...params.map(p => p.value));
      }

      _computeFilters(elementEntities, initialDisplayedInheritance) {
        if (!(elementEntities instanceof Array) ||
            !(initialDisplayedInheritance instanceof Array)) return;
            
        let filters = [];
        
        const findFilterForInheritance = inheritedFrom =>
          filters.find(filter => filter.inheritedFrom === inheritedFrom);
        
        for (let {items: entityItems} of elementEntities) {
          for (let {inheritedFrom = this.constructor.notInheritedLabel} of entityItems) {
            if (findFilterForInheritance(inheritedFrom)) continue;

            const value = {
              inheritedFrom,
              selected: initialDisplayedInheritance.includes(inheritedFrom),
              public: true,
              private: false,
              protected: false
            };

            filters.push(value);
          }
        }

        return filters;
      }

      _groupHasAttachment(attachments, groupName) {
        if (attachments === undefined || groupName === undefined) return;

        return Object.keys(attachments).includes(groupName);
      }

      _getAttachment(attachments, groupName) {
        if (attachments === undefined || groupName === undefined) return;

        return attachments[groupName];
      }

    }

    window.customElements.define(PaperSandbox.is, PaperSandbox);

  </script>
</dom-module>
